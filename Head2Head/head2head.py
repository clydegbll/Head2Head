# -*- coding: utf-8 -*-
"""Head2Head

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qirFbZkhg-HrAZcXYfpZoM3E4Wqi2-TQ

This project will analyze champion matchups from the game League of Legends and will try to predict the winner of a matchup based on previous instances of that matchup.

### **IMPORT CELL**
"""

#Wrap that'll allow us to grab stuff from Riot's API
!pip install riotwatcher

#imports:
from riotwatcher import LolWatcher, ApiError
import requests
import json
import time
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score
import numpy as np
from sklearn.model_selection import train_test_split

"""### ***DO NOT RUN THESE NEXT TWO CELLS; DEVS ONLY***"""

API_key = "RGAPI-ffc01a4c-8726-4d29-8bf6-86ed37ad9373"
watcher = LolWatcher(API_key)
regionformat1 = 'na1'
my_region = 'americas'
base_url = "https://na1.api.riotgames.com"

entries = watcher.league.challenger_by_queue(regionformat1, 'RANKED_SOLO_5x5').get('entries')
matchlist = []
for item in entries:
  try:
    summoner_name = item.get('summonerName')
    #get the item.summonername? use that to get puuid, get matches by puuid
    thispuuid = watcher.summoner.by_name(regionformat1,summoner_name).get('puuid')
    matchlist.extend(watcher.match.matchlist_by_puuid(my_region,thispuuid, count= 20))
  except:
    print("Skipped one!")
print(matchlist)

"""Use API endpoint call to retrieve and store Match Data"""

import time
import json 
matches = []
minimatchlist = matchlist[0:200]
print(minimatchlist)
for matchid in minimatchlist:
  try:
    thismatch = watcher.match.by_id(my_region, match_id=str(matchid))
    particpantsList = thismatch.get('info').get('participants')
    thisMatch = {}
    thisMatch['teamMembers'] = []
    for participant in particpantsList:
      if participant.get('teamPosition') =="":
        raise Exception("no position")
      thisMatch['teamMembers'].append({
        'champion': participant.get('championName'),
        'champ_id': participant.get('championId'),
        'kda': participant.get('kills') - participant.get('deaths') + .5*(participant.get('assists')),
        'position': participant.get('teamPosition')
      })
    matches.append(thisMatch)
  except Exception as e: 
    continue
with open('matchData.txt', 'w') as outfile:
    json.dump(matches, outfile)

  #matchData.write("[")
  #for particpant in particpantsList:
    #champion = particpant.get('championName')
    #kdascore = particpant.get('kills') - particpant.get('deaths') + .5*(particpant.get('assists'))
    #position = particpant.get('teamPosition')
    #matchData.write("["+champion + "," + str(kdascore) + "," +position +"]" )
  #matchData.write("]" + "\n")

"""Create X and y sets by going through each head to head matchup and comparing the KDA of those in the same role, and add an entry with an array of the ChampionID [length 2] to the X set and the outcome (0 if the first champion wins, 1 if the second does) to the y data set

### ***DATA PROCESSING: RUN EVERY CELL AFTER THIS***
"""

import json
x = []
y = []

with open('matchData.txt') as json_file:
  
  data = json.load(json_file)
  print(len(data))
  i = 0
  for match in data: 
    i+=1
    try:
      positions = {
        'tops':[member for member in match['teamMembers'] if member.get('position') == 'TOP'],
        'bottoms':[member for member in match['teamMembers'] if member.get('position') == 'BOTTOM'],
        'mids' : [member for member in match['teamMembers'] if member.get('position') == 'MIDDLE'],
        'utils': [member for member in match['teamMembers'] if member.get('position') == 'UTILITY'],
        'jungs': [member for member in match['teamMembers'] if member.get('position') == 'JUNGLE']
      }
      for pos,val in positions.items():
        
        x.append([val[0].get('champ_id'),val[1].get('champ_id')])
        #now compare members in val list: add champ names and winner data to x and 
        if (val[0].get('kda')>val[1].get('kda')):
          y.append([0])
        else:
          y.append([1])

    except Exception as e:
      #print("threw exception") 
      continue
print(x)
print(y)

"""Separate x and y data into Training and test data sets"""

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=123)

"""

1.   Train Models
2.   Try different hyperparameters
3.   Test each, calculate accuracy and speed



"""

print("Random Forest Model:")
print("====================================== \n")

f_time = []
f_score = []
for n in [5, 50, 100, 144]:
  rf = RandomForestClassifier(n_estimators = n, random_state = 42)
  start = time.time()

  rf.fit(X_train, np.ravel(y_train,order="c"))
  rf_prediction = rf.predict(X_test)

  end = time.time()
  n_time = end - start
  f_time.append(n_time)
  
  score = accuracy_score(y_test, rf_prediction)
  f_score.append(score)
  print("After taking " , n_time, "seconds to compute, the accuracy score for n = " , n, " in the Random Forest model is: ", score)

avg_time = sum(f_time) / len(f_time)
avg_score = sum(f_score) / len(f_score)

print("\nThe Random Forest model had an average runtime of: " , avg_time , "seconds, and an average accuracy score of: ", avg_score)
print("\n======================================")

from google.colab import drive
drive.mount('/content/drive')

print("SVC Model:")
print("====================================== \n")

#svc with different Cs
Cs = [0.05, .1, 1, 10, 30]
c_time = []
c_score = []

for c in Cs:
  modelSVC = SVC(C=c)
  start = time.time()
  #the training
  modelSVC.fit(X_train, np.ravel(y_train,order="c"))
  svc_prediction = modelSVC.predict(X_test)
  end = time.time()
  svc_time = end - start
  #adding the times/scores for each C-value so the average can be found
  c_time.append(svc_time)
  c_score.append(accuracy_score(y_test, svc_prediction))
  #print statement
  print("After taking " , svc_time, "seconds to compute, the accuracy score for value C = " , c, " in the SVC model is: ", accuracy_score(y_test, svc_prediction))

#Getting avg time and score
avg_time = sum(c_time) / len(c_time)
avg_score = sum(c_score) / len(c_score)
print('\n')
#print statement
print("The SVC model had an average runtime of: " , avg_time , "seconds, and an average accuracy score of: ", avg_score)
print("\n======================================")